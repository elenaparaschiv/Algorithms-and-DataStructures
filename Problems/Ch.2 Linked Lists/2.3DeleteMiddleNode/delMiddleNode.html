<script src="tinyTest.js"></script>
<script>

/**
  Delete Middle Node:
  Implement algorithm to delete a node in the middle
  (i.e., any node but the first and last node) of a singly linked list
  given only access to that node.
*/

// Solution is to copy the data from the next node over the current node
// and delete the next node.

function LinkedList (value) {
  this.value = value;
  this.next = null;
};

function deleteMidNode(midNode) {
  // does not delete an inexistent node or the last node
  while (midNode !== null && midNode.next !== null ) {
    midNode.value = midNode.next.value;
    if(midNode.next.next === null) {
      midNode.next = null;
    }
    midNode = midNode.next;
  }
};

var printList = function(head) {
  while(head !== null) {
    console.log(head.value);
    head = head.next;
  }
  console.log('done printing');
};

/* TEST */

var printList = function(head) {
  while(head !== null) {
    console.log(head.value);
    head = head.next;
  }
  console.log('done printing');
};

// Tests
//1.
var a = new LinkedList('a');
var b = new LinkedList('b');
var c = new LinkedList('c');
var d = new LinkedList('d');
var e = new LinkedList('e');
var f = new LinkedList('f');

a.next = b;
b.next = c;
c.next = d;
d.next = e;
e.next = f;

printList(a);
deleteMidNode(c);
printList(a);
// Output: deletes node c

//2.
var a = new LinkedList('a');
var b = new LinkedList('b');
var c = new LinkedList('c');

a.next = b;
b.next = c;

printList(a);
deleteMidNode(b);
printList(a);
//Output: deletes node b

//3.
var a = new LinkedList('a');
var b = new LinkedList('b');

a.next = b;

printList(a);
deleteMidNode(b);
printList(a);
// Output: does not delete node b because it is the last element

/** [TO FIX: cannot delete the first node in the linked list.
(giving only access to the currentNode and not the head).]
*/
</script>
